#include <dirent.h>  //opendir()/readdir()/closedir()
#include <errno.h>
#include <error.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

#include "helpers.h"

int dopath(const char *pathname, int depth, FILE *dest) {
  struct stat statbuf;
  struct dirent *dirp;
  DIR *dp;

  if (depth != 0 && (strcmp(pathname, ".") == 0 || strcmp(pathname, "..") == 0))
    return 0;

  if (lstat(pathname, &statbuf) < 0) {
    switch (errno) {
      case EBADF:
        printf("Not a valid open file descriptor.");
        break;
      case ENOENT:
        printf(
            "A component of pathname does not exist or "
            "is a dangling symbolic link.");
        break;
      case ENOTDIR:
        printf("A component of the path prefix of pathname is not a directory.");
        break;
      case ELOOP:
        printf("Too many symbolic links encountered while traversing the path.");
        break;
      case EFAULT:
        printf("Bad address. ");
        break;
      case EACCES:
        printf(
            "Search  permission  is  denied for one of the directories in "
            "the path prefix of pathname.");
        break;
      case ENOMEM:
        printf("Out of memory (i.e., kernel memory).");
        break;
      case ENAMETOOLONG:
        printf("pathname is too long.");
        break;
      case EOVERFLOW:
        printf(
            "pathname or fd refers to a file whose  size,  inode  number,  or"
            "number  of  blocks  cannot  be represented in s.");
        break;
    }
    printf("Can't lstat.");
    return -1;
  }

  for (int i = 0; i < depth; ++i) fprintf(dest, "       |");
  fprintf(dest, "_");

  if (S_ISDIR(statbuf.st_mode) == 0) {
    fprintf(dest, "%s\n", pathname);
    return 0;
  }

  /* каталог */
  fprintf(dest, "%s\n", pathname);
  if ((dp = opendir(pathname)) == NULL) {
    printf("couldn't open directory '%s'\n", pathname);
    return -1;
  }

  if (chdir(pathname) == -1) {
    printf("can't chdir.");
    return -1;
  }

    while ((dirp = readdir(dp)) != NULL) dopath(dirp->d_name, depth + 1, dest);
    if (chdir ("..") == -1) {
      printf("can't chdir.");
      return -1;
    }

    if (closedir(dp) == -1) {
      printf("can't chdir.");
      return -1;
    }
}

char *STAT_TEMPLATE[TEMPLATE_SIZE] = {
    "pid - ID процесса - %s\n",
    "comm - Имя файла - %s\n",
    "state - Состояние процесса - %s\n",
    "ppid - ID родительского процесса - %s\n",
    "pgrp - ID группы процесса - %s\n",
    "session - ID сессии процесса - %s\n",
    "tty_nr - управляющий терминал процесса - %s\n",
    "tpgid - ID внешней группы процессов управляющего терминала - %s\n",
    "flags - Флаги ядра процесса - %s\n",
    "minflt - Количество минорных ошибок процесса (Минорные ошибки не "
    "включают ошибки загрузки страниц памяти с диска) - %s\n",
    "cminflt - Количество минорных ошибок дочерних процессов (Минорные "
    "ошибки не включают ошибки загрузки страниц памяти с диска) - %s\n",
    "ajflt - Количество Мажоных ошибок процесса - %s\n",
    "cmajflt - Количество Мажоных ошибок дочерних процессов процесса - %s\n",
    "utime - Количество времени, в течение которого этот процесс был "
    "запланирован в пользовательском режиме - %s\n",
    "stime - Количество времени, в течение которого этот процесс был "
    "запланирован в режиме ядра - %s\n",
    "cutime - Количество времени, в течение которого ожидаемые дети этого "
    "процесса были запланированы в пользовательском режиме - %s\n",
    "cstime - Количество времени, в течение которого ожидаемые дети этого "
    "процесса были запланированы в режиме ядра - %s\n",
    "priority - Приоритет процесса - %s\n",
    "nice - nice\n"
    "num_threads - Количество потоков - %s\n",
    "itrealvalue - Время в тиках до следующего SIGALRM отправленного в "
    "процесс из-за интервального таймера - %s\n",
    "starttiime - Время с начала загрузки системы - %s\n",
    "vsize - Объем виртуальной памяти в байтах - %s\n",
    "rss - Resident Set Size: Количество страниц процесса в физической "
    "памяти - %s\n",
    "rsslim - Текущий лимит в байтах на RSS процесса - %s\n",
    "startcode - Адрес, над которым может работать текст программы - %s\n",
    "endcode - Адрес, над которым может работать текст программы - %s\n",
    "startstack - Адрес начала (т. е. дна) стека - %s\n",
    " kstkesp - Текущее значение ESP (Stack pointer), найденное на странице "
    "стека ядра для данного процесса - %s\n",
    "kstkeip - Текущее значение EIP (instruction pointer) - %s\n",
    "signal - Растровое изображение отложенных сигналов, отображаемое в "
    "виде десятичного числа - %s\n",
    "blocked - Растровое изображение заблокированных сигналов, отображаемое "
    "в виде десятичного числа - %s\n",
    "sigignore - Растровое изображение игнорированных сигналов, "
    "отображаемое в виде десятичного числа - %s\n",
    "sigcatch - Растровое изображение пойманных сигналов, отображаемое в "
    "виде десятичного числа - %s\n",
    "wchan - Канал, в котором происходит ожидание процесса - %s\n",
    "nswap - Количество страниц, поменявшихся местами - %s\n",
    "cnswap - Накопительный своп для дочерних процессов - %s\n",
    "exit_signal - Сигнал, который будет послан родителю, когда процесс "
    "будет завершен - %s\n",
    "processor - Номер процессора, на котором было последнее выполнение - %s\n",
    "rt_priority - Приоритет планирования в реальном времени- число в "
    "диапазоне от 1 до 99 для процессов, запланированных в соответствии с "
    "политикой реального времени - %s\n",
    "policy - Политика планирования - %s\n",
    "delayacct_blkio_tics - Общие блочные задержки ввода/вывода - %s\n",
    "quest_time - Гостевое время процесса - %s\n",
    "cquest_time - Гостевое время  дочерних процессов - %s\n",
    "start_data - Адрес, над которым размещаются инициализированные и "
    "неинициализированные данные программы (BSS) - %s\n",
    "end_data - Адрес, под которым размещаются инициализированные и "
    "неинициализированные данные программы (BSS)"
    "start_brk - Адрес, выше которого куча программ может быть расширена с "
    "помощью brk - %s\n",
    "arg_start - Адрес, над которым размещаются аргументы командной строки "
    "программы (argv) - %s\n",
    "arg_end - Адрес, под которым размещаются аргументы командной строки "
    "программы (argv) - %s\n",
    "env_start - Адрес, над которым размещена программная среда - %s\n",
    "env_end - Адрес, под которым размещена программная среда - %s\n",
    "exit_code - Состояние выхода потока в форме, сообщаемой waitpid - %s\n"};

char *ENVIRON_TEMPLATE[TEMPLATE_SIZE] = {
    " - путь к предпочтительной оболочке командной строки.\n",
    "\n",
    "\n",
    "\n",
    "- определяет поддержку 24-битного цвета.\n",
    " - переменная, необходимая для вызова xdg-open, использующейся для "
    "открытия файла или URL в пользовательском приложении.\n",
    "\n",
    " - переменная, необходимая для вызова xdg-open, использующейся для "
    "открытия файла или URL в пользовательском приложении.\n",
    "переменная среды рабочего стола GNOME.\n",
    "\n",
    "\n",
    "\n",
    "- переменная среды рабочего стола GNOME.\n",
    "\n",
    " - путь к сокету, который агент использует для коммуникации с другими "
    "процессами.\n",
    "\n",
    " - переменная, необходимая для вызова xdg-open, использующейся для "
    "открытия файла или URL в пользовательском приложении.\n",
    "\n",
    "идентификатор процесса ssh-agent.\n",
    "\n",
    "\n",
    "- путь к рабочей директории\n",
    "- имя текущего пользователя\n",
    " - переменная, необходимая для вызова xdg-open, использующейся для "
    "открытия файла или URL в пользовательском приложении.\n",
    " - переменная, необходимая для вызова xdg-open, использующейся для "
    "открытия файла или URL в пользовательском приложении.\n",
    "\n",
    "\n",
    "\n",
    "- путь к домашнему каталогу текущего пользователя\n",
    "- имя пользователя, кто инициировал запуск процесса\n",
    "\n",
    "\n",
    "- управление региональными настройками\n",
    "- используется для определения цветов, с которыми будут выведены имена "
    "файлов при вызове ls.\n",
    " - переменная, необходимая для вызова xdg-open, использующейся для "
    "открытия файла или URL в пользовательском приложении.\n",
    "\n",
    "переменная среды рабочего стола GNOME.\n",
    "\n",
    "\n",
    " - переменная, необходимая для вызова xdg-open, использующейся для "
    "открытия файла или URL в пользовательском приложении.\n",
    " - тип запущенного терминала.",
    "\n",
    "\n",
    "\n",
    "- имя пользователя, от чьего имени запущен процесс.\n",
    "- переменная среды рабочего стола GNOME.\n",
    "- указывает приложениям, куда отобразить графический пользовательский "
    "интерфейс.\n",
    "- уровень текущей командной оболочки.\n",
    "- Предпочитаемая пользователем утилита просмотра текстовых файлов.\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    " - переменная, необходимая для вызова xdg-open, использующейся для "
    "открытия файла или URL в пользовательском приложении.\n",
    "- форматы времени и даты в локали.\n",
    "\n",
    " - переменная, необходимая для вызова xdg-open, использующейся для "
    "открытия файла или URL в пользовательском приложении.\n",
    "список каталогов, в которых система ищет исполняемые файлы.\n",
    "\n",
    "\n",
    "\n",
    "путь к предыдущему рабочему каталогу.\n",
    " полная командная строка процесса\n"};